"use client"

import { useEffect, useRef, useState } from "react"
import { ScrollArea } from "@/components/ui/scroll-area"
import { usePentest } from "@/contexts/pentest-context"
import { useConnection } from "@/contexts/connection-context"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

export default function PentestConsole() {
  const { consoleEntries, isRunning, addConsoleEntry, setConnectionStatus } = usePentest()
  const { config: connectionConfig } = useConnection()
  const scrollRef = useRef<HTMLDivElement>(null)
  const wsRef = useRef<WebSocket | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectAttemptsRef = useRef(0)
  const lastConnectionAttemptRef = useRef(0)
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const isConnectingRef = useRef(false)
  const MAX_RECONNECT_ATTEMPTS = 5
  const CONNECTION_COOLDOWN = 2000 // 2 seconds
  const HEARTBEAT_INTERVAL = 30000 // 30 seconds to match server

  const hasValidCredentials = () => {
    if (!connectionConfig.host || !connectionConfig.port || !connectionConfig.username) {
      return false
    }
    if (connectionConfig.useSshKey && !connectionConfig.sshKey) {
      return false
    }
    if (!connectionConfig.useSshKey && !connectionConfig.password) {
      return false
    }
    return true
  }

  const cleanupWsResources = () => {
    console.log('Cleaning WebSocket resources');
    if (wsRef.current) {
      wsRef.current.onopen = null;
      wsRef.current.onmessage = null;
      wsRef.current.onerror = null;
      wsRef.current.onclose = null;
      
      // Only try to close if not already closing/closed
      if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
        wsRef.current.close(1000, "Client cleanup");
      }
      
      wsRef.current = null;
    }
    setIsConnected(false);
    setConnectionStatus("disconnected");
  }

  const cleanupSystemTimers = () => {
    console.log('Clearing reconnect and heartbeat timers.');
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
  }

  const connectWebSocket = () => {
    if (!hasValidCredentials()) {
      console.log('Missing SSH credentials. Aborting connection attempt.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
      return;
    }

    if (isConnectingRef.current || (wsRef.current && wsRef.current.readyState === WebSocket.OPEN)) {
      return;
    }

    console.log('Preparing for new connection attempt');
    cleanupWsResources();
    cleanupSystemTimers();

    isConnectingRef.current = true;
    setConnectionStatus("connecting");
    console.log(`Attempting connection (Attempt ${reconnectAttemptsRef.current + 1}/${MAX_RECONNECT_ATTEMPTS})`);
    lastConnectionAttemptRef.current = Date.now();

    try {
      const ws = new WebSocket('ws://localhost:8080');
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('WebSocket connected successfully');
        setIsConnected(true);
        setConnectionStatus("connected");
        isConnectingRef.current = false;
        reconnectAttemptsRef.current = 0;
        cleanupSystemTimers();
        addConsoleEntry({ type: 'system', content: 'Connected to server', timestamp: new Date().toISOString() });
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // Handle ping/pong
          if (data.type === 'pong') {
            return;
          }
          if (data.type === 'ping') {
            console.log('Ping received from server, sending pong.');
            if(wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
              wsRef.current.send(JSON.stringify({ type: 'pong' }));
            }
            return;
          }

          switch (data.type) {
            case 'output':
              addConsoleEntry({ type: 'output', content: data.content, timestamp: new Date().toISOString() });
              break;
            case 'error':
              console.error('Processing server error message:', data.message || data.content);
              addConsoleEntry({ type: 'system', content: `Error: ${data.message || data.content}`, timestamp: new Date().toISOString() });
              break;
            case 'system':
              if (!data.content.includes('Connection') && !data.content.includes('connection')) {
                addConsoleEntry({ type: 'system', content: data.content, timestamp: new Date().toISOString() });
              }
              break;
            case 'ai':
              addConsoleEntry({ type: 'ai', content: data.content, timestamp: new Date().toISOString() });
              break;
            default:
              console.log('Unknown message type:', data.type);
          }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
          console.error('Raw message that caused error:', event.data);
        }
      };

      ws.onerror = (errorEvent) => {
        console.error('WebSocket error event:', errorEvent);
        setConnectionStatus("error");
        addConsoleEntry({ type: 'system', content: 'Connection error occurred.', timestamp: new Date().toISOString() });
        if (wsRef.current === ws) {
            isConnectingRef.current = false;
        }
      };

      ws.onclose = (closeEvent) => {
        console.log('WebSocket connection closed:', closeEvent.code, closeEvent.reason);
        isConnectingRef.current = false;
        if (isConnected) setIsConnected(false);
        setConnectionStatus("disconnected");
        
        cleanupSystemTimers();

        if (wsRef.current === ws && hasValidCredentials()) {
          wsRef.current = null;
          console.log('Scheduling reconnect due to closure with valid credentials.');
          scheduleReconnect();
        } else if (wsRef.current === ws) {
          wsRef.current = null;
          console.log('WebSocket closed, not reconnecting (missing credentials or manual close).');
        }
      };
    } catch (error) {
      console.error('Error creating WebSocket instance:', error);
      isConnectingRef.current = false;
      setConnectionStatus("error");
      addConsoleEntry({ type: 'system', content: 'Failed to establish connection. Please check if the server is running.', timestamp: new Date().toISOString() });
      if (hasValidCredentials()) {
        scheduleReconnect();
      }
    }
  };
  
  const scheduleReconnect = () => {
    if (isConnectingRef.current) {
        console.log("Aborting reconnect, connection attempt already in progress.");
        return;
    }
    if (!hasValidCredentials()) {
        console.log("Aborting reconnect, no valid credentials.");
        return;
    }

    reconnectAttemptsRef.current++;
    if (reconnectAttemptsRef.current > MAX_RECONNECT_ATTEMPTS) {
      console.error('Max reconnection attempts reached. Please check server or refresh.');
      addConsoleEntry({ type: 'system', content: 'Failed to connect to server after multiple attempts. Please refresh.', timestamp: new Date().toISOString() });
      reconnectAttemptsRef.current = 0;
      setConnectionStatus("error");
      return;
    }

    const backoff = Math.min(2 ** reconnectAttemptsRef.current * 1000, 10000);
    console.log(`Reconnecting in ${backoff}ms... (Attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS})`);
    
    if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);
    reconnectTimeoutRef.current = setTimeout(() => {
      reconnectTimeoutRef.current = null;
      connectWebSocket();
    }, backoff);
  };

  const startHeartbeat = () => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
    }
    
    heartbeatIntervalRef.current = setInterval(() => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        console.log('Sending heartbeat ping to server');
        wsRef.current.send(JSON.stringify({ type: 'ping' }));
      }
    }, HEARTBEAT_INTERVAL);
  };

  // Handle custom events from pentest context
  useEffect(() => {
    const handleStartPentest = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      } else {
        addConsoleEntry({ 
          type: 'system', 
          content: 'Cannot start pentest: not connected to server', 
          timestamp: new Date().toISOString() 
        });
      }
    };

    const handleStopPentest = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      }
    };

    const handleSendApproval = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      }
    };

    window.addEventListener('startPentest', handleStartPentest as EventListener);
    window.addEventListener('stopPentest', handleStopPentest as EventListener);
    window.addEventListener('sendApproval', handleSendApproval as EventListener);

    return () => {
      window.removeEventListener('startPentest', handleStartPentest as EventListener);
      window.removeEventListener('stopPentest', handleStopPentest as EventListener);
      window.removeEventListener('sendApproval', handleSendApproval as EventListener);
    };
  }, [addConsoleEntry]);

  useEffect(() => {
    console.log('useEffect [connectionConfig]: Fired. Checking credentials and connection state.');
    if (hasValidCredentials()) {
      console.log('useEffect: Credentials are valid.');
      if ((!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED) && !isConnectingRef.current) {
        console.log('useEffect: No active or pending connection. Initiating connectWebSocket.');
        reconnectAttemptsRef.current = 0;
        connectWebSocket();
      } else {
        console.log(`useEffect: Not connecting. wsRef.current state: ${wsRef.current?.readyState}, isConnecting: ${isConnectingRef.current}`);
      }
    } else {
      console.log('useEffect: Credentials are NOT valid. Cleaning up all resources.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
      reconnectAttemptsRef.current = 0;
    }

    return () => {
      console.log('useEffect cleanup [connectionConfig]: Component unmounting or config changed. Cleaning up.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
    };
  }, [connectionConfig]);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" })
    }
  }, [consoleEntries])

  const getEntryColor = (type: string) => {
    switch (type) {
      case "command":
        return "text-cyan-400"
      case "output":
        return "text-slate-200 dark:text-slate-300"
      case "ai":
        return "text-emerald-400"
      case "system":
        return "text-amber-400"
      default:
        return "text-slate-200 dark:text-slate-300"
    }
  }

  const getEntryPrefix = (type: string) => {
    switch (type) {
      case "command":
        return "$ "
      case "output":
        return ""
      case "ai":
        return "[AI] "
      case "system":
        return "[SYSTEM] "
      default:
        return ""
    }
  }

  const formatTimestamp = (timestamp: string) => {
    try {
      if (!isNaN(Number(timestamp))) {
        return new Date(Number(timestamp) * 1000).toLocaleTimeString()
      }
      return new Date(timestamp).toLocaleTimeString()
    } catch (e) {
      return "00:00:00"
    }
  }

  const sendCommand = (command: string) => {
    if (!isConnected || !wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      addConsoleEntry({
        type: 'system',
        content: 'Not connected to server. Please wait or check credentials.',
        timestamp: new Date().toISOString()
      });
      if (hasValidCredentials() && !isConnectingRef.current && (!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED)) {
        console.log('sendCommand: Not connected. Attempting to connect first.');
        reconnectAttemptsRef.current = 0;
        connectWebSocket();
      }
      return;
    }

    if (!hasValidCredentials()) {
      console.error('sendCommand: Missing SSH credentials.');
      addConsoleEntry({ type: 'system', content: 'Missing SSH credentials.', timestamp: new Date().toISOString() });
      return;
    }

    console.log('Sending command:', command);
    console.log('Connection details:', {
      host: connectionConfig.host,
      port: connectionConfig.port,
      username: connectionConfig.username,
      useSshKey: connectionConfig.useSshKey
    });
    
    addConsoleEntry({
      type: 'command',
      content: command,
      timestamp: new Date().toISOString()
    });

    const message = {
      type: 'command',
      command,
      connection: {
        host: connectionConfig.host,
        port: connectionConfig.port,
        username: connectionConfig.username,
        password: connectionConfig.useSshKey ? undefined : connectionConfig.password,
        sshKey: connectionConfig.useSshKey ? connectionConfig.sshKey : undefined,
        useSshKey: connectionConfig.useSshKey
      }
    }
    
    try {
      console.log('Sending message to backend:', message)
      wsRef.current.send(JSON.stringify(message))
    } catch (error) {
      console.error('Error sending command:', error)
      addConsoleEntry({
        type: 'system',
        content: 'Failed to send command. Please try again.',
        timestamp: new Date().toISOString()
      })
      if (error instanceof Error && error.message.includes('WebSocket')) {
        connectWebSocket()
      }
    }
  }

  // Sync connection state with context
  useEffect(() => {
    if (isConnected) {
      setConnectionStatus("connected");
    } else if (isConnectingRef.current) {
      setConnectionStatus("connecting");
    } else {
      setConnectionStatus("disconnected");
    }
  }, [isConnected, setConnectionStatus]);

  return (
    <div className="h-full flex flex-col bg-slate-900 dark:bg-slate-950">
      <div className="px-6 py-4 border-b border-slate-700/50">
        <h3 className="text-lg font-semibold text-white">Terminal Output</h3>
        <p className="text-sm text-slate-400">Real-time penetration testing console</p>
      </div>

      <ScrollArea className="flex-1 scrollbar-sleek">
        <div className="p-6 font-mono text-sm space-y-2 min-h-full">
          {consoleEntries.length === 0 && !isRunning && (
            <div className="flex items-center justify-center h-64">
              <div className="text-center">
                <div className="w-16 h-16 mx-auto mb-4 rounded-2xl bg-gradient-to-br from-indigo-500/20 to-purple-500/20 flex items-center justify-center">
                  <span className="text-2xl">⚡</span>
                </div>
                <p className="text-slate-400 text-base font-sans">Start a pentest to see console output...</p>
              </div>
            </div>
          )}

          {consoleEntries.map((entry, index) => (
            <div key={index} className={`${getEntryColor(entry.type)} leading-relaxed`}>
              <span className="text-slate-500 text-xs mr-3">{formatTimestamp(entry.timestamp)}</span>
              <span className="font-bold">{getEntryPrefix(entry.type)}</span>
              <span className="break-words">{entry.content}</span>
            </div>
          ))}
          <div ref={scrollRef} />
        </div>
      </ScrollArea>

      <div className="p-4 border-t border-slate-700/50">
        <div className="flex items-center space-x-2">
          <Input
            placeholder="Enter command..."
            className="flex-1 bg-slate-800 border-slate-700 text-white"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                const command = e.currentTarget.value
                if (command) {
                  sendCommand(command)
                  e.currentTarget.value = ''
                }
              }
            }}
          />
          <Button
            onClick={() => {
              const input = document.querySelector('input[placeholder="Enter command..."]') as HTMLInputElement
              const command = input.value
              if (command) {
                sendCommand(command)
                input.value = ''
              }
            }}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Send
          </Button>
        </div>
      </div>
    </div>
  )
}

