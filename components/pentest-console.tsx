"use client"

import { useEffect, useRef, useState } from "react"
import { ScrollArea } from "@/components/ui/scroll-area"
import { usePentest } from "@/contexts/pentest-context"
import { useConnection } from "@/contexts/connection-context"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Terminal } from 'xterm'
import { FitAddon } from 'xterm-addon-fit'
import ResizeObserver from 'resize-observer-polyfill'

export default function PentestConsole() {
  const { consoleEntries, isRunning, addConsoleEntry, setConnectionStatus } = usePentest()
  const { config: connectionConfig } = useConnection()
  const scrollRef = useRef<HTMLDivElement>(null)
  const wsRef = useRef<WebSocket | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const reconnectAttemptsRef = useRef(0)
  const lastConnectionAttemptRef = useRef(0)
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const isConnectingRef = useRef(false)
  const MAX_RECONNECT_ATTEMPTS = 5
  const CONNECTION_COOLDOWN = 2000 // 2 seconds
  const HEARTBEAT_INTERVAL = 30000 // 30 seconds to match server
  const [terminal, setTerminal] = useState<Terminal | null>(null)
  const [terminalContainer, setTerminalContainer] = useState<HTMLDivElement | null>(null)
  const [commandHistory, setCommandHistory] = useState<string[]>([])
  const [historyIndex, setHistoryIndex] = useState(-1)
  const [isProcessing, setIsProcessing] = useState(false)
  const [currentCommand, setCurrentCommand] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const terminalRef = useRef<Terminal | null>(null)
  const fitAddonRef = useRef<FitAddon | null>(null)
  const resizeObserverRef = useRef<ResizeObserver | null>(null)

  const hasValidCredentials = () => {
    if (!connectionConfig.host || !connectionConfig.port || !connectionConfig.username) {
      return false
    }
    if (connectionConfig.useSshKey && !connectionConfig.sshKey) {
      return false
    }
    if (!connectionConfig.useSshKey && !connectionConfig.password) {
      return false
    }
    return true
  }

  const cleanupWsResources = () => {
    console.log('Cleaning WebSocket resources');
    if (wsRef.current) {
      wsRef.current.onopen = null;
      wsRef.current.onmessage = null;
      wsRef.current.onerror = null;
      wsRef.current.onclose = null;
      
      // Only try to close if not already closing/closed
      if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
        wsRef.current.close(1000, "Client cleanup");
      }
      
      wsRef.current = null;
    }
    setIsConnected(false);
    setConnectionStatus("disconnected");
  }

  const cleanupSystemTimers = () => {
    console.log('Clearing reconnect and heartbeat timers.');
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
  }

  const connectWebSocket = () => {
    if (!hasValidCredentials()) {
      console.log('Missing SSH credentials. Aborting connection attempt.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
      return;
    }

    if (isConnectingRef.current || (wsRef.current && wsRef.current.readyState === WebSocket.OPEN)) {
      return;
    }

    console.log('Preparing for new connection attempt');
    cleanupWsResources();
    cleanupSystemTimers();

    isConnectingRef.current = true;
    setConnectionStatus("connecting");
    console.log(`Attempting connection (Attempt ${reconnectAttemptsRef.current + 1}/${MAX_RECONNECT_ATTEMPTS})`);
    lastConnectionAttemptRef.current = Date.now();

    try {
      const ws = new WebSocket('ws://localhost:8080');
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('WebSocket connected successfully');
        setIsConnected(true);
        setConnectionStatus("connected");
        isConnectingRef.current = false;
        reconnectAttemptsRef.current = 0;
        cleanupSystemTimers();
        addConsoleEntry({ type: 'system', content: 'Connected to server', timestamp: new Date().toISOString() });
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // Handle ping/pong
          if (data.type === 'pong') {
            return;
          }
          if (data.type === 'ping') {
            console.log('Ping received from server, sending pong.');
            if(wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
              wsRef.current.send(JSON.stringify({ type: 'pong' }));
            }
            return;
          }

          switch (data.type) {
            case 'output':
              addConsoleEntry({ type: 'output', content: data.content, timestamp: new Date().toISOString() });
              break;
            case 'command':
              addConsoleEntry({ type: 'command', content: data.command, timestamp: new Date().toISOString() });
              // Send the command back to the server for execution
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                wsRef.current.send(JSON.stringify({
                  type: 'command',
                  command: data.command,
                  connection: connectionConfig
                }));
              }
              break;
            case 'error':
              console.error('Processing server error message:', data.message || data.content);
              addConsoleEntry({ type: 'system', content: `Error: ${data.message || data.content}`, timestamp: new Date().toISOString() });
              break;
            case 'system':
              if (!data.content.includes('Connection') && !data.content.includes('connection')) {
                addConsoleEntry({ type: 'system', content: data.content, timestamp: new Date().toISOString() });
              }
              break;
            case 'ai':
              addConsoleEntry({ type: 'ai', content: data.content, timestamp: new Date().toISOString() });
              break;
            default:
              console.log('Unknown message type:', data.type);
          }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
          console.error('Raw message that caused error:', event.data);
        }
      };

      ws.onerror = (errorEvent) => {
        console.error('WebSocket error event:', errorEvent);
        setConnectionStatus("error");
        addConsoleEntry({ type: 'system', content: 'Connection error occurred.', timestamp: new Date().toISOString() });
        if (wsRef.current === ws) {
            isConnectingRef.current = false;
        }
      };

      ws.onclose = (closeEvent) => {
        console.log('WebSocket connection closed:', closeEvent.code, closeEvent.reason);
        isConnectingRef.current = false;
        if (isConnected) setIsConnected(false);
        setConnectionStatus("disconnected");
        
        cleanupSystemTimers();

        if (wsRef.current === ws && hasValidCredentials()) {
          wsRef.current = null;
          console.log('Scheduling reconnect due to closure with valid credentials.');
          scheduleReconnect();
        } else if (wsRef.current === ws) {
          wsRef.current = null;
          console.log('WebSocket closed, not reconnecting (missing credentials or manual close).');
        }
      };
    } catch (error) {
      console.error('Error creating WebSocket instance:', error);
      isConnectingRef.current = false;
      setConnectionStatus("error");
      addConsoleEntry({ type: 'system', content: 'Failed to establish connection. Please check if the server is running.', timestamp: new Date().toISOString() });
      if (hasValidCredentials()) {
        scheduleReconnect();
      }
    }
  };
  
  const scheduleReconnect = () => {
    if (isConnectingRef.current) {
        console.log("Aborting reconnect, connection attempt already in progress.");
        return;
    }
    if (!hasValidCredentials()) {
        console.log("Aborting reconnect, no valid credentials.");
        return;
    }

    reconnectAttemptsRef.current++;
    if (reconnectAttemptsRef.current > MAX_RECONNECT_ATTEMPTS) {
      console.error('Max reconnection attempts reached. Please check server or refresh.');
      addConsoleEntry({ type: 'system', content: 'Failed to connect to server after multiple attempts. Please refresh.', timestamp: new Date().toISOString() });
      reconnectAttemptsRef.current = 0;
      setConnectionStatus("error");
      return;
    }

    const backoff = Math.min(2 ** reconnectAttemptsRef.current * 1000, 10000);
    console.log(`Reconnecting in ${backoff}ms... (Attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS})`);
    
    if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);
    reconnectTimeoutRef.current = setTimeout(() => {
      reconnectTimeoutRef.current = null;
      connectWebSocket();
    }, backoff);
  };

  const startHeartbeat = () => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
    }
    
    heartbeatIntervalRef.current = setInterval(() => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        console.log('Sending heartbeat ping to server');
        wsRef.current.send(JSON.stringify({ type: 'ping' }));
      }
    }, HEARTBEAT_INTERVAL);
  };

  // Handle custom events from pentest context
  useEffect(() => {
    const handleStartPentest = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      } else {
        addConsoleEntry({ 
          type: 'system', 
          content: 'Cannot start pentest: not connected to server', 
          timestamp: new Date().toISOString() 
        });
      }
    };

    const handleStopPentest = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      }
    };

    const handleSendApproval = (event: CustomEvent) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(event.detail));
      }
    };

    window.addEventListener('startPentest', handleStartPentest as EventListener);
    window.addEventListener('stopPentest', handleStopPentest as EventListener);
    window.addEventListener('sendApproval', handleSendApproval as EventListener);

    return () => {
      window.removeEventListener('startPentest', handleStartPentest as EventListener);
      window.removeEventListener('stopPentest', handleStopPentest as EventListener);
      window.removeEventListener('sendApproval', handleSendApproval as EventListener);
    };
  }, [addConsoleEntry]);

  useEffect(() => {
    console.log('useEffect [connectionConfig]: Fired. Checking credentials and connection state.');
    if (hasValidCredentials()) {
      console.log('useEffect: Credentials are valid.');
      if ((!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED) && !isConnectingRef.current) {
        console.log('useEffect: No active or pending connection. Initiating connectWebSocket.');
        reconnectAttemptsRef.current = 0;
        connectWebSocket();
      } else {
        console.log(`useEffect: Not connecting. wsRef.current state: ${wsRef.current?.readyState}, isConnecting: ${isConnectingRef.current}`);
      }
    } else {
      console.log('useEffect: Credentials are NOT valid. Cleaning up all resources.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
      reconnectAttemptsRef.current = 0;
    }

    return () => {
      console.log('useEffect cleanup [connectionConfig]: Component unmounting or config changed. Cleaning up.');
      cleanupWsResources();
      cleanupSystemTimers();
      isConnectingRef.current = false;
    };
  }, [connectionConfig]);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" })
    }
  }, [consoleEntries])

  const getEntryColor = (type: string) => {
    switch (type) {
      case "command":
        return "text-cyan-400"
      case "output":
        return "text-slate-200 dark:text-slate-300"
      case "ai":
        return "text-emerald-400"
      case "system":
        return "text-amber-400"
      default:
        return "text-slate-200 dark:text-slate-300"
    }
  }

  const getEntryPrefix = (type: string) => {
    switch (type) {
      case "command":
        return "$ "
      case "output":
        return ""
      case "ai":
        return "[AI] "
      case "system":
        return "[SYSTEM] "
      default:
        return ""
    }
  }

  const formatTimestamp = (timestamp: string) => {
    try {
      if (!isNaN(Number(timestamp))) {
        return new Date(Number(timestamp) * 1000).toLocaleTimeString()
      }
      return new Date(timestamp).toLocaleTimeString()
    } catch (e) {
      return "00:00:00"
    }
  }

  const sendCommand = (command: string) => {
    if (!isConnected || !wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      addConsoleEntry({
        type: 'system',
        content: 'Not connected to server. Please wait or check credentials.',
        timestamp: new Date().toISOString()
      });
      if (hasValidCredentials() && !isConnectingRef.current && (!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED)) {
        console.log('sendCommand: Not connected. Attempting to connect first.');
        reconnectAttemptsRef.current = 0;
        connectWebSocket();
      }
      return;
    }

    if (!hasValidCredentials()) {
      console.error('sendCommand: Missing SSH credentials.');
      addConsoleEntry({ type: 'system', content: 'Missing SSH credentials.', timestamp: new Date().toISOString() });
      return;
    }

    console.log('Sending command:', command);
    console.log('Connection details:', {
      host: connectionConfig.host,
      port: connectionConfig.port,
      username: connectionConfig.username,
      useSshKey: connectionConfig.useSshKey
    });
    
    // Display the command in the terminal
    if (terminalRef.current) {
      terminalRef.current.write('\x1b[32m$ ' + command + '\x1b[0m\n');
    }

    const message = {
      type: 'command',
      command,
      connection: {
        host: connectionConfig.host,
        port: connectionConfig.port,
        username: connectionConfig.username,
        password: connectionConfig.useSshKey ? undefined : connectionConfig.password,
        sshKey: connectionConfig.useSshKey ? connectionConfig.sshKey : undefined,
        useSshKey: connectionConfig.useSshKey
      }
    }
    
    try {
      console.log('Sending message to backend:', JSON.stringify(message, null, 2));
      wsRef.current.send(JSON.stringify(message));
      console.log('Message sent successfully');
    } catch (error) {
      console.error('Error sending command:', error);
      if (terminalRef.current) {
        terminalRef.current.write('\x1b[31mError: Failed to send command. Please try again.\x1b[0m\n');
      }
      if (error instanceof Error && error.message.includes('WebSocket')) {
        connectWebSocket();
      }
    }
  }

  // Sync connection state with context
  useEffect(() => {
    if (isConnected) {
      setConnectionStatus("connected");
    } else if (isConnectingRef.current) {
      setConnectionStatus("connecting");
    } else {
      setConnectionStatus("disconnected");
    }
  }, [isConnected, setConnectionStatus]);

  useEffect(() => {
    if (terminalContainer) {
      const term = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
        scrollback: 10000,
        convertEol: true,
        allowTransparency: true,
        rows: 24,
        cols: 80,
        theme: {
          background: '#1a1a1a',
          foreground: '#ffffff',
          cursor: '#ffffff',
          black: '#000000',
          red: '#ff5555',
          green: '#50fa7b',
          yellow: '#f1fa8c',
          blue: '#bd93f9',
          magenta: '#ff79c6',
          cyan: '#8be9fd',
          white: '#f8f8f2',
          brightBlack: '#6272a4',
          brightRed: '#ff6e67',
          brightGreen: '#69fa90',
          brightYellow: '#ffffa5',
          brightBlue: '#d6acff',
          brightMagenta: '#ff92d0',
          brightCyan: '#a4ffff',
          brightWhite: '#ffffff'
        }
      });

      const fitAddon = new FitAddon();
      term.loadAddon(fitAddon);
      term.open(terminalContainer);
      
      // Initial fit after a short delay
      setTimeout(() => fitAddon.fit(), 1);

      // Handle terminal data
      term.onData((data: string) => {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: 'command',
            command: data,
            connection: connectionConfig
          }));
        }
      });

      // Handle terminal resize
      term.onResize(({ cols, rows }: { cols: number; rows: number }) => {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: 'resize',
            cols,
            rows
          }));
        }
      });

      // Fit the terminal when the container is resized
      const resizeObserver = new ResizeObserver(() => {
        if (terminalContainer) {
          const { width, height } = terminalContainer.getBoundingClientRect();
          const cols = Math.floor(width / 9); // Approximate character width
          const rows = Math.floor(height / 20); // Approximate line height
          
          term.resize(cols, rows);
          fitAddon.fit();
          
          if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({
              type: 'resize',
              cols,
              rows
            }));
          }
        }
      });
      resizeObserver.observe(terminalContainer);

      setTerminal(term);
      terminalRef.current = term;
      fitAddonRef.current = fitAddon;

      return () => {
        resizeObserver.disconnect();
        term.dispose();
      };
    }
  }, [terminalContainer]);

  useEffect(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('Received WebSocket message:', data);
          
          switch (data.type) {
            case 'output':
              if (terminalRef.current) {
                terminalRef.current.write(data.content);
                terminalRef.current.scrollToBottom();
              }
              break;
            case 'command':
              if (terminalRef.current) {
                terminalRef.current.write('\x1b[32m$ ' + data.command + '\x1b[0m\n');
                terminalRef.current.scrollToBottom();
                // Execute the command by sending it back to the server
                if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                  wsRef.current.send(JSON.stringify({
                    type: 'command',
                    command: data.command,
                    connection: connectionConfig
                  }));
                }
              }
              break;
            case 'error':
              if (terminalRef.current) {
                terminalRef.current.write('\x1b[31m' + data.content + '\x1b[0m\n');
                terminalRef.current.scrollToBottom();
              }
              break;
            case 'system':
              if (terminalRef.current) {
                terminalRef.current.write('\x1b[33m' + data.content + '\x1b[0m\n');
                terminalRef.current.scrollToBottom();
              }
              break;
            case 'ping':
              // Handle ping messages
              break;
            default:
              console.log('Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('Error parsing WebSocket message:', e);
        }
      };
    }
  }, [wsRef.current?.readyState]);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      const command = e.currentTarget.value
      if (command) {
        sendCommand(command)
        e.currentTarget.value = ''
      }
    }
  }

  const handleSendCommand = () => {
    if (!isConnected || isProcessing || !currentCommand.trim()) {
      return;
    }

    setIsProcessing(true);
    sendCommand(currentCommand);
    setCurrentCommand('');
  }

  return (
    <div className="flex flex-col h-full">
      <div className="flex-none p-4 border-b">
        <div className="flex items-center space-x-4">
          <div className="flex-1">
            <Input
              type="text"
              placeholder="Enter command..."
              value={currentCommand}
              onChange={(e) => setCurrentCommand(e.target.value)}
              onKeyDown={handleKeyDown}
              disabled={!isConnected || isProcessing}
              className="font-mono"
            />
          </div>
          <Button
            onClick={handleSendCommand}
            disabled={!isConnected || isProcessing || !currentCommand.trim()}
          >
            {isProcessing ? 'Processing...' : 'Send'}
          </Button>
        </div>
      </div>
      <div className="flex-1 relative">
        <div
          ref={setTerminalContainer}
          className="w-full h-full bg-[#1a1a1a] overflow-hidden relative"
          style={{ height: 'calc(100vh - 200px)' }}
        >
          <style jsx global>{`
            .xterm-helper-textarea {
              position: absolute !important;
              opacity: 0;
              left: -9999px !important;
              top: -9999px !important;
              width: 0 !important;
              height: 0 !important;
              z-index: -1 !important;
              overflow: hidden !important;
            }
            .xterm-char-measure-element {
              position: absolute !important;
              visibility: hidden !important;
              top: -9999px !important;
              left: -9999px !important;
              z-index: -1 !important;
            }
            .xterm-viewport {
              overflow-y: auto !important;
              scrollbar-width: thin !important;
              scrollbar-color: rgba(148, 163, 184, 0.3) transparent !important;
              background-color: transparent !important;
            }
            .xterm-viewport::-webkit-scrollbar {
              width: 4px !important;
            }
            .xterm-viewport::-webkit-scrollbar-track {
              background: transparent !important;
            }
            .xterm-viewport::-webkit-scrollbar-thumb {
              background: rgba(148, 163, 184, 0.3) !important;
              border-radius: 2px !important;
            }
            .xterm-viewport::-webkit-scrollbar-thumb:hover {
              background: rgba(148, 163, 184, 0.5) !important;
            }
            .xterm-screen {
              position: relative !important;
            }
            .xterm-rows {
              position: relative !important;
              z-index: 1 !important;
            }
            .xterm-scroll-area {
              position: absolute !important;
              top: 0 !important;
              left: 0 !important;
              right: 0 !important;
              bottom: 0 !important;
              z-index: 0 !important;
            }
          `}</style>
        </div>
      </div>
    </div>
  )
}

