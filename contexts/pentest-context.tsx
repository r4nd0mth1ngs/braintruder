"use client"

import { createContext, useContext, useState, type ReactNode } from "react"
import { useToast } from "@/hooks/use-toast"
import { useTools } from "@/contexts/tools-context"
import { useConnection } from "@/contexts/connection-context"
import { useAI } from "@/contexts/ai-context"

// Define types for our context
export interface ConsoleEntry {
  type: "command" | "output" | "ai" | "system"
  content: string
  timestamp: string
}

export interface Finding {
  title: string
  description: string
  severity: "Low" | "Medium" | "High" | "Critical"
  timestamp: string
}

export interface Alert {
  title: string
  message: string
  severity: "info" | "warning" | "error"
  timestamp: string
}

export interface ApprovalRequest {
  id: string
  action: string
  risk: string
}

type ConnectionStatus = "disconnected" | "connecting" | "connected" | "error"

interface PentestContextType {
  isRunning: boolean
  target: string
  setTarget: (target: string) => void
  additionalInfo: string
  setAdditionalInfo: (info: string) => void
  consoleEntries: ConsoleEntry[]
  findings: Finding[]
  alerts: Alert[]
  pendingApproval: ApprovalRequest | null
  connectionStatus: ConnectionStatus
  setConnectionStatus: (status: ConnectionStatus) => void
  startPentest: () => void
  stopPentest: () => void
  approveAction: (id: string) => void
  denyAction: (id: string) => void
  showToolSelection: boolean
  setShowToolSelection: (show: boolean) => void
  showConnectionConfig: boolean
  setShowConnectionConfig: (show: boolean) => void
  showAIConfig: boolean
  setShowAIConfig: (show: boolean) => void
  addConsoleEntry: (entry: ConsoleEntry) => void
}

const PentestContext = createContext<PentestContextType | undefined>(undefined)

export function PentestProvider({ children }: { children: ReactNode }) {
  const [isRunning, setIsRunning] = useState(false)
  const [target, setTarget] = useState("")
  const [additionalInfo, setAdditionalInfo] = useState("")
  const [sessionId, setSessionId] = useState<string | null>(null)
  const [consoleEntries, setConsoleEntries] = useState<ConsoleEntry[]>([])
  const [findings, setFindings] = useState<Finding[]>([])
  const [alerts, setAlerts] = useState<Alert[]>([])
  const [pendingApproval, setPendingApproval] = useState<ApprovalRequest | null>(null)
  const [showToolSelection, setShowToolSelection] = useState(false)
  const [showConnectionConfig, setShowConnectionConfig] = useState(false)
  const [showAIConfig, setShowAIConfig] = useState(false)
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("disconnected")
  const { toast } = useToast()
  const { selectedTools, tools, headlessMode } = useTools()
  const { config: connectionConfig, status: connectionConfigStatus } = useConnection()
  const { config: aiConfig, getActivePromptTemplate } = useAI()

  const startPentest = () => {
    if (!target) {
      toast({
        title: "Target required",
        description: "Please enter a target URL or IP address",
        variant: "destructive",
      })
      return
    }

    if (connectionConfigStatus !== "connected") {
      toast({
        title: "Connection required",
        description: "Please connect to a Kali/Parrot system first",
        variant: "destructive",
      })
      setShowConnectionConfig(true)
      return
    }

    // Clear previous state
    setConsoleEntries([])
    setFindings([])
    setAlerts([])
    setPendingApproval(null)

    // Create the pentest payload
    const payload = {
      target,
      additionalInfo,
      headlessMode,
      tools: selectedTools,
      connection: connectionConfig,
      ai: {
        ...aiConfig,
        systemPrompt: getActivePromptTemplate()
      }
    }

    console.log("Starting pentest with payload:", payload)

    // Send start_pentest message via WebSocket
    // The pentest-console component will handle the actual WebSocket communication
    const startMessage = {
      type: "start_pentest",
      ...payload
    }

    // Add to console to show we're starting
    addConsoleEntry({
      type: "system",
      content: `Starting pentest on ${target}...`,
      timestamp: new Date().toISOString()
    })

    // The actual sending will be handled by pentest-console component
    // We'll create a custom event to communicate this
    window.dispatchEvent(new CustomEvent('startPentest', { detail: startMessage }))
  }

  const stopPentest = () => {
    if (!sessionId) return

    // Send stop message via WebSocket
    const stopMessage = {
      type: "stop_pentest",
      sessionId
    }

    // The actual sending will be handled by pentest-console component
    window.dispatchEvent(new CustomEvent('stopPentest', { detail: stopMessage }))
  }

  const approveAction = (id: string) => {
    if (!pendingApproval) return

    // Send approval message via WebSocket
    const approvalMessage = {
      type: "approval_response",
      requestId: id,
      approved: true
    }

    window.dispatchEvent(new CustomEvent('sendApproval', { detail: approvalMessage }))
  }

  const denyAction = (id: string) => {
    if (!pendingApproval) return

    // Send denial message via WebSocket
    const denialMessage = {
      type: "approval_response",
      requestId: id,
      approved: false
    }

    window.dispatchEvent(new CustomEvent('sendApproval', { detail: denialMessage }))
  }

  const addConsoleEntry = (entry: ConsoleEntry) => {
    setConsoleEntries((prev) => [...prev, entry])
  }

  const value: PentestContextType = {
    isRunning,
    target,
    setTarget,
    additionalInfo,
    setAdditionalInfo,
    consoleEntries,
    findings,
    alerts,
    pendingApproval,
    connectionStatus,
    setConnectionStatus,
    startPentest,
    stopPentest,
    approveAction,
    denyAction,
    showToolSelection,
    setShowToolSelection,
    showConnectionConfig,
    setShowConnectionConfig,
    showAIConfig,
    setShowAIConfig,
    addConsoleEntry,
  }

  return (
    <PentestContext.Provider value={value}>
      {children}
    </PentestContext.Provider>
  )
}

export function usePentest() {
  const context = useContext(PentestContext)
  if (context === undefined) {
    throw new Error("usePentest must be used within a PentestProvider")
  }
  return context
}
