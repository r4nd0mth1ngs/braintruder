"use client"

import { createContext, useContext, useState, type ReactNode } from "react"
import { useWebSocket } from "@/hooks/use-websocket"
import { useToast } from "@/hooks/use-toast"
import { useTools } from "@/contexts/tools-context"
import { useConnection } from "@/contexts/connection-context"
import { useAI } from "@/contexts/ai-context"

// Define types for our context
export interface ConsoleEntry {
  type: "command" | "output" | "ai" | "system"
  content: string
  timestamp: string
}

export interface Finding {
  title: string
  description: string
  severity: "Low" | "Medium" | "High" | "Critical"
  timestamp: string
}

export interface Alert {
  title: string
  message: string
  severity: "info" | "warning" | "error"
  timestamp: string
}

export interface ApprovalRequest {
  id: string
  action: string
  risk: string
}

interface PentestContextType {
  isRunning: boolean
  target: string
  setTarget: (target: string) => void
  additionalInfo: string
  setAdditionalInfo: (info: string) => void
  consoleEntries: ConsoleEntry[]
  findings: Finding[]
  alerts: Alert[]
  pendingApproval: ApprovalRequest | null
  connectionStatus: string
  startPentest: () => void
  stopPentest: () => void
  approveAction: (id: string) => void
  denyAction: (id: string) => void
  showToolSelection: boolean
  setShowToolSelection: (show: boolean) => void
  showConnectionConfig: boolean
  setShowConnectionConfig: (show: boolean) => void
  showAIConfig: boolean
  setShowAIConfig: (show: boolean) => void
  addConsoleEntry: (entry: ConsoleEntry) => void
}

const PentestContext = createContext<PentestContextType | undefined>(undefined)

export function PentestProvider({ children }: { children: ReactNode }) {
  const [isRunning, setIsRunning] = useState(false)
  const [target, setTarget] = useState("")
  const [additionalInfo, setAdditionalInfo] = useState("")
  const [sessionId, setSessionId] = useState<string | null>(null)
  const [consoleEntries, setConsoleEntries] = useState<ConsoleEntry[]>([])
  const [findings, setFindings] = useState<Finding[]>([])
  const [alerts, setAlerts] = useState<Alert[]>([])
  const [pendingApproval, setPendingApproval] = useState<ApprovalRequest | null>(null)
  const [showToolSelection, setShowToolSelection] = useState(false)
  const [showConnectionConfig, setShowConnectionConfig] = useState(false)
  const [showAIConfig, setShowAIConfig] = useState(false)
  const { toast } = useToast()
  const { selectedTools, tools, headlessMode } = useTools()
  const { config: connectionConfig, status: connectionStatus } = useConnection()
  const { config: aiConfig, getActivePromptTemplate } = useAI()

  // In a real app, this would be an environment variable or configuration
  const wsUrl = "ws://localhost:8765"

  const { status: wsStatus, send } = useWebSocket({
    url: wsUrl,
    autoConnect: false,
    onOpen: () => {
      toast({
        title: "Connected to pentest server",
        description: "Ready to start pentesting",
      })
    },
    onClose: () => {
      if (isRunning) {
        toast({
          title: "Disconnected from pentest server",
          description: "Connection lost. Pentest may be interrupted.",
          variant: "destructive",
        })
        setIsRunning(false)
      }
    },
    onMessage: (event) => {
      try {
        const message = JSON.parse(event.data)
        handleWebSocketMessage(message)
      } catch (error) {
        console.error("Failed to parse WebSocket message:", error)
      }
    },
    onError: () => {
      toast({
        title: "Connection error",
        description: "Failed to connect to the pentest server",
        variant: "destructive",
      })
    },
  })

  const handleWebSocketMessage = (message: any) => {
    switch (message.type) {
      case "console":
        if (message.entry) {
          setConsoleEntries((prev) => [...prev, message.entry])
        }
        break
      case "finding":
        if (message.finding) {
          setFindings((prev) => [...prev, message.finding])
          toast({
            title: "New finding",
            description: `${message.finding.title} (${message.finding.severity})`,
          })
        }
        break
      case "alert":
        if (message.alert) {
          setAlerts((prev) => [...prev, message.alert])
          toast({
            title: "Alert",
            description: message.alert.message,
            variant: message.alert.severity === "error" ? "destructive" : "default",
          })
        }
        break
      case "approval":
        if (message.request) {
          setPendingApproval(message.request)
          toast({
            title: "Action approval required",
            description: "The AI is requesting permission for a potentially risky action",
          })
        }
        break
      case "status":
        if (message.status === "started") {
          setSessionId(message.sessionId)
          setIsRunning(true)
          toast({
            title: "Pentest started",
            description: `Session ID: ${message.sessionId}`,
          })
        } else if (message.status === "stopped") {
          setIsRunning(false)
          setSessionId(null)
          toast({
            title: "Pentest stopped",
            description: "The pentest has been completed or stopped",
          })
        } else if (message.status === "approved" || message.status === "denied") {
          setPendingApproval(null)
        }
        break
      default:
        console.log("Unknown message type:", message)
    }
  }

  const startPentest = () => {
    if (!target) {
      toast({
        title: "Target required",
        description: "Please enter a target URL or IP address",
        variant: "destructive",
      })
      return
    }

    if (connectionStatus !== "connected") {
      toast({
        title: "Connection required",
        description: "Please connect to a Kali/Parrot system first",
        variant: "destructive",
      })
      setShowConnectionConfig(true)
      return
    }

    // Clear previous state
    setConsoleEntries([])
    setFindings([])
    setAlerts([])
    setPendingApproval(null)

    // Get the selected tools with their parameters (if not in headless mode)
    const selectedToolsConfig = headlessMode
      ? []
      : tools
          .filter((tool) => tool.enabled)
          .map((tool) => ({
            id: tool.id,
            parameters: tool.parameters.reduce(
              (acc, param) => ({
                ...acc,
                [param.name]: param.value,
              }),
              {},
            ),
          }))

    // Get the active prompt template
    const activeTemplate = getActivePromptTemplate()

    // Replace variables in the prompt template
    let systemPrompt = activeTemplate?.systemPrompt || ""
    if (activeTemplate) {
      systemPrompt = systemPrompt.replace(/\{\{TARGET\}\}/g, target)
      systemPrompt = systemPrompt.replace(
        /\{\{ADDITIONAL_INFO\}\}/g,
        additionalInfo || "No additional information provided.",
      )
    }

    // Send start command to WebSocket server
    send({
      command: "start",
      target,
      additionalInfo,
      headlessMode,
      tools: selectedToolsConfig,
      connection: {
        method: connectionConfig.method,
        host: connectionConfig.host,
        port: connectionConfig.port,
        // Don't send sensitive information like passwords or SSH keys in plain text
        // In a real implementation, you would use a secure method to handle credentials
        hasCredentials:
          connectionConfig.method === "ssh"
            ? connectionConfig.useSshKey
              ? !!connectionConfig.sshKey
              : !!connectionConfig.password
            : connectionConfig.method === "api"
              ? !!connectionConfig.apiKey
              : true,
      },
      ai: {
        provider: aiConfig.provider,
        model: aiConfig.model,
        temperature: aiConfig.temperature,
        maxTokens: aiConfig.maxTokens,
        systemPrompt,
      },
    })
  }

  const stopPentest = () => {
    if (sessionId) {
      send({
        command: "stop",
        sessionId,
      })
    }
  }

  const approveAction = (id: string) => {
    if (sessionId && pendingApproval && pendingApproval.id === id) {
      send({
        command: "approve",
        sessionId,
        approvalId: id,
      })
    }
  }

  const denyAction = (id: string) => {
    if (sessionId && pendingApproval && pendingApproval.id === id) {
      send({
        command: "deny",
        sessionId,
        approvalId: id,
      })
    }
  }

  const addConsoleEntry = (entry: ConsoleEntry) => {
    setConsoleEntries(prev => [...prev, entry])
  }

  return (
    <PentestContext.Provider
      value={{
        isRunning,
        target,
        setTarget,
        additionalInfo,
        setAdditionalInfo,
        consoleEntries,
        findings,
        alerts,
        pendingApproval,
        connectionStatus: wsStatus,
        startPentest,
        stopPentest,
        approveAction,
        denyAction,
        showToolSelection,
        setShowToolSelection,
        showConnectionConfig,
        setShowConnectionConfig,
        showAIConfig,
        setShowAIConfig,
        addConsoleEntry,
      }}
    >
      {children}
    </PentestContext.Provider>
  )
}

export function usePentest() {
  const context = useContext(PentestContext)
  if (context === undefined) {
    throw new Error("usePentest must be used within a PentestProvider")
  }
  return context
}
